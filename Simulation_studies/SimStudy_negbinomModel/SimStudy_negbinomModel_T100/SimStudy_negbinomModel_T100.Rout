> ###############################################################################
> #
> #
> # Gompertz Model with Poisson Sampling Error: Correct Model
> #
> #
> ###############################################################################
> 
> 
> 
> 
> 
> ############################### Initialization ################################
> 
> ### set the seed
> set.seed(1994)
> 
> 
> 
> ##### set environment for simulation study
> 
> ### compile stan model
> # translation
> rstan::stanc("../stan_model.stan")
$status
[1] TRUE

$model_cppname
[1] "model26fc174283a851_stan_model"

$cppcode
[1] "#ifndef USE_STANC3\n#define USE_STANC3\n#endif\n// Code generated by stanc v2.32.2\n#include <stan/model/model_header.hpp>\nnamespace model26fc174283a851_stan_model_namespace {\nusing stan::model::model_base_crtp;\nusing namespace stan::math;\nstan::math::profile_map profiles__;\nstatic constexpr std::array<const char*, 26> locations_array__ =\n  {\" (found before start of program)\",\n  \" (in 'stan_model', line 6, column 2 to column 14)\",\n  \" (in 'stan_model', line 7, column 2 to column 9)\",\n  \" (in 'stan_model', line 8, column 2 to column 23)\",\n  \" (in 'stan_model', line 9, column 2 to column 23)\",\n  \" (in 'stan_model', line 12, column 2 to column 15)\",\n  \" (in 'stan_model', line 13, column 2 to column 22)\",\n  \" (in 'stan_model', line 15, column 2 to column 29)\",\n  \" (in 'stan_model', line 20, column 6 to column 54)\",\n  \" (in 'stan_model', line 19, column 19 to line 21, column 5)\",\n  \" (in 'stan_model', line 19, column 4 to line 21, column 5)\",\n  \" (in 'stan_model', line 18, column 17 to line 22, column 3)\",\n  \" (in 'stan_model', line 18, column 2 to line 22, column 3)\",\n  \" (in 'stan_model', line 28, column 2 to column 31)\",\n  \" (in 'stan_model', line 29, column 2 to column 38)\",\n  \" (in 'stan_model', line 30, column 2 to column 21)\",\n  \" (in 'stan_model', line 33, column 2 to column 35)\",\n  \" (in 'stan_model', line 36, column 4 to column 29)\",\n  \" (in 'stan_model', line 35, column 15 to line 37, column 3)\",\n  \" (in 'stan_model', line 35, column 2 to line 37, column 3)\",\n  \" (in 'stan_model', line 2, column 2 to column 17)\",\n  \" (in 'stan_model', line 3, column 12 to column 13)\",\n  \" (in 'stan_model', line 3, column 2 to column 15)\",\n  \" (in 'stan_model', line 9, column 18 to column 19)\",\n  \" (in 'stan_model', line 12, column 9 to column 10)\",\n  \" (in 'stan_model', line 13, column 13 to column 14)\"};\nclass model26fc174283a851_stan_model final : public model_base_crtp<model26fc174283a851_stan_model> {\nprivate:\n  int M;\n  std::vector<int> Nstar;\npublic:\n  ~model26fc174283a851_stan_model() {}\n  model26fc174283a851_stan_model(stan::io::var_context& context__,\n                                 unsigned int random_seed__ = 0,\n                                 std::ostream* pstream__ = nullptr)\n      : model_base_crtp(0) {\n    int current_statement__ = 0;\n    using local_scalar_t__ = double;\n    boost::ecuyer1988 base_rng__ =\n      stan::services::util::create_rng(random_seed__, 0);\n    // suppress unused var warning\n    (void) base_rng__;\n    static constexpr const char* function__ =\n      \"model26fc174283a851_stan_model_namespace::model26fc174283a851_stan_model\";\n    // suppress unused var warning\n    (void) function__;\n    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n    // suppress unused var warning\n    (void) DUMMY_VAR__;\n    try {\n      int pos__ = std::numeric_limits<int>::min();\n      pos__ = 1;\n      current_statement__ = 20;\n      context__.validate_dims(\"data initialization\", \"M\", \"int\",\n        std::vector<size_t>{});\n      M = std::numeric_limits<int>::min();\n      current_statement__ = 20;\n      M = context__.vals_i(\"M\")[(1 - 1)];\n      current_statement__ = 20;\n      stan::math::check_greater_or_equal(function__, \"M\", M, 0);\n      current_statement__ = 21;\n      stan::math::validate_non_negative_index(\"Nstar\", \"M\", M);\n      current_statement__ = 22;\n      context__.validate_dims(\"data initialization\", \"Nstar\", \"int\",\n        std::vector<size_t>{static_cast<size_t>(M)});\n      Nstar = std::vector<int>(M, std::numeric_limits<int>::min());\n      current_statement__ = 22;\n      Nstar = context__.vals_i(\"Nstar\");\n      current_statement__ = 23;\n      stan::math::validate_non_negative_index(\"N\", \"M\", M);\n      current_statement__ = 24;\n      stan::math::validate_non_negative_index(\"mu\", \"M\", M);\n      current_statement__ = 25;\n      stan::math::validate_non_negative_index(\"Sigma\", \"M\", M);\n      current_statement__ = 25;\n      stan::math::validate_non_negative_index(\"Sigma\", \"M\", M);\n    } catch (const std::exception& e) {\n      stan::lang::rethrow_located(e, locations_array__[current_statement__]);\n    }\n    num_params_r__ = 1 + 1 + 1 + M;\n  }\n  inline std::string model_name() const final {\n    return \"model26fc174283a851_stan_model\";\n  }\n  inline std::vector<std::string> model_compile_info() const noexcept {\n    return std::vector<std::string>{\"stanc_version = stanc3 v2.32.2\",\n             \"stancflags = --\"};\n  }\n  template <bool propto__, bool jacobian__, typename VecR, typename VecI,\n            stan::require_vector_like_t<VecR>* = nullptr,\n            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>\n  inline stan::scalar_type_t<VecR>\n  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*\n                pstream__ = nullptr) const {\n    using T__ = stan::scalar_type_t<VecR>;\n    using local_scalar_t__ = T__;\n    T__ lp__(0.0);\n    stan::math::accumulator<T__> lp_accum__;\n    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);\n    int current_statement__ = 0;\n    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n    // suppress unused var warning\n    (void) DUMMY_VAR__;\n    static constexpr const char* function__ =\n      \"model26fc174283a851_stan_model_namespace::log_prob\";\n    // suppress unused var warning\n    (void) function__;\n    try {\n      local_scalar_t__ theta1 = DUMMY_VAR__;\n      current_statement__ = 1;\n      theta1 = in__.template read<local_scalar_t__>();\n      local_scalar_t__ b = DUMMY_VAR__;\n      current_statement__ = 2;\n      b = in__.template read<local_scalar_t__>();\n      local_scalar_t__ theta2 = DUMMY_VAR__;\n      current_statement__ = 3;\n      theta2 = in__.template read_constrain_lb<local_scalar_t__,\n                 jacobian__>(0, lp__);\n      Eigen::Matrix<local_scalar_t__,-1,1> N =\n        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);\n      current_statement__ = 4;\n      N = in__.template read_constrain_lb<\n            Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__, M);\n      Eigen::Matrix<local_scalar_t__,-1,1> mu =\n        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);\n      Eigen::Matrix<local_scalar_t__,-1,-1> Sigma =\n        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(M, M, DUMMY_VAR__);\n      current_statement__ = 7;\n      stan::model::assign(mu, stan::math::rep_vector(theta1, M),\n        \"assigning variable mu\");\n      current_statement__ = 12;\n      for (int i = 1; i <= M; ++i) {\n        current_statement__ = 10;\n        for (int j = 1; j <= M; ++j) {\n          current_statement__ = 8;\n          stan::model::assign(Sigma, (theta2 *\n            stan::math::pow((1 + b), stan::math::abs((i - j)))),\n            \"assigning variable Sigma\", stan::model::index_uni(i),\n            stan::model::index_uni(j));\n        }\n      }\n      current_statement__ = 6;\n      stan::math::check_cov_matrix(function__, \"Sigma\", Sigma);\n      {\n        current_statement__ = 13;\n        lp_accum__.add(stan::math::inv_gamma_lpdf<propto__>(theta2, 0.1, 0.1));\n        current_statement__ = 14;\n        lp_accum__.add(stan::math::normal_lpdf<propto__>(theta1, 0, (10 *\n                         stan::math::sqrt(theta2))));\n        current_statement__ = 15;\n        lp_accum__.add(stan::math::uniform_lpdf<propto__>(b, -2, 0));\n        current_statement__ = 16;\n        lp_accum__.add(stan::math::multi_normal_lpdf<propto__>(\n                         stan::math::log(N), mu, Sigma));\n        current_statement__ = 19;\n        for (int i = 1; i <= M; ++i) {\n          current_statement__ = 17;\n          lp_accum__.add(stan::math::poisson_lpmf<propto__>(\n                           stan::model::rvalue(Nstar, \"Nstar\",\n                             stan::model::index_uni(i)),\n                           stan::model::rvalue(N, \"N\",\n                             stan::model::index_uni(i))));\n        }\n      }\n    } catch (const std::exception& e) {\n      stan::lang::rethrow_located(e, locations_array__[current_statement__]);\n    }\n    lp_accum__.add(lp__);\n    return lp_accum__.sum();\n  }\n  template <typename RNG, typename VecR, typename VecI, typename VecVar,\n            stan::require_vector_like_vt<std::is_floating_point,\n            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,\n            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,\n            VecVar>* = nullptr>\n  inline void\n  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,\n                   VecVar& vars__, const bool\n                   emit_transformed_parameters__ = true, const bool\n                   emit_generated_quantities__ = true, std::ostream*\n                   pstream__ = nullptr) const {\n    using local_scalar_t__ = double;\n    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);\n    stan::io::serializer<local_scalar_t__> out__(vars__);\n    static constexpr bool propto__ = true;\n    // suppress unused var warning\n    (void) propto__;\n    double lp__ = 0.0;\n    // suppress unused var warning\n    (void) lp__;\n    int current_statement__ = 0;\n    stan::math::accumulator<double> lp_accum__;\n    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n    // suppress unused var warning\n    (void) DUMMY_VAR__;\n    constexpr bool jacobian__ = false;\n    static constexpr const char* function__ =\n      \"model26fc174283a851_stan_model_namespace::write_array\";\n    // suppress unused var warning\n    (void) function__;\n    try {\n      double theta1 = std::numeric_limits<double>::quiet_NaN();\n      current_statement__ = 1;\n      theta1 = in__.template read<local_scalar_t__>();\n      double b = std::numeric_limits<double>::quiet_NaN();\n      current_statement__ = 2;\n      b = in__.template read<local_scalar_t__>();\n      double theta2 = std::numeric_limits<double>::quiet_NaN();\n      current_statement__ = 3;\n      theta2 = in__.template read_constrain_lb<local_scalar_t__,\n                 jacobian__>(0, lp__);\n      Eigen::Matrix<double,-1,1> N =\n        Eigen::Matrix<double,-1,1>::Constant(M,\n          std::numeric_limits<double>::quiet_NaN());\n      current_statement__ = 4;\n      N = in__.template read_constrain_lb<\n            Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__, M);\n      Eigen::Matrix<double,-1,1> mu =\n        Eigen::Matrix<double,-1,1>::Constant(M,\n          std::numeric_limits<double>::quiet_NaN());\n      Eigen::Matrix<double,-1,-1> Sigma =\n        Eigen::Matrix<double,-1,-1>::Constant(M, M,\n          std::numeric_limits<double>::quiet_NaN());\n      out__.write(theta1);\n      out__.write(b);\n      out__.write(theta2);\n      out__.write(N);\n      if (stan::math::logical_negation(\n            (stan::math::primitive_value(emit_transformed_parameters__) ||\n            stan::math::primitive_value(emit_generated_quantities__)))) {\n        return ;\n      }\n      current_statement__ = 7;\n      stan::model::assign(mu, stan::math::rep_vector(theta1, M),\n        \"assigning variable mu\");\n      current_statement__ = 12;\n      for (int i = 1; i <= M; ++i) {\n        current_statement__ = 10;\n        for (int j = 1; j <= M; ++j) {\n          current_statement__ = 8;\n          stan::model::assign(Sigma, (theta2 *\n            stan::math::pow((1 + b), stan::math::abs((i - j)))),\n            \"assigning variable Sigma\", stan::model::index_uni(i),\n            stan::model::index_uni(j));\n        }\n      }\n      current_statement__ = 6;\n      stan::math::check_cov_matrix(function__, \"Sigma\", Sigma);\n      if (emit_transformed_parameters__) {\n        out__.write(mu);\n        out__.write(Sigma);\n      }\n      if (stan::math::logical_negation(emit_generated_quantities__)) {\n        return ;\n      }\n    } catch (const std::exception& e) {\n      stan::lang::rethrow_located(e, locations_array__[current_statement__]);\n    }\n  }\n  template <typename VecVar, typename VecI,\n            stan::require_vector_t<VecVar>* = nullptr,\n            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>\n  inline void\n  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,\n                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {\n    using local_scalar_t__ = double;\n    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);\n    stan::io::serializer<local_scalar_t__> out__(vars__);\n    int current_statement__ = 0;\n    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n    // suppress unused var warning\n    (void) DUMMY_VAR__;\n    try {\n      int pos__ = std::numeric_limits<int>::min();\n      pos__ = 1;\n      local_scalar_t__ theta1 = DUMMY_VAR__;\n      current_statement__ = 1;\n      theta1 = in__.read<local_scalar_t__>();\n      out__.write(theta1);\n      local_scalar_t__ b = DUMMY_VAR__;\n      current_statement__ = 2;\n      b = in__.read<local_scalar_t__>();\n      out__.write(b);\n      local_scalar_t__ theta2 = DUMMY_VAR__;\n      current_statement__ = 3;\n      theta2 = in__.read<local_scalar_t__>();\n      out__.write_free_lb(0, theta2);\n      Eigen::Matrix<local_scalar_t__,-1,1> N =\n        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);\n      current_statement__ = 4;\n      stan::model::assign(N,\n        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(M),\n        \"assigning variable N\");\n      out__.write_free_lb(0, N);\n    } catch (const std::exception& e) {\n      stan::lang::rethrow_located(e, locations_array__[current_statement__]);\n    }\n  }\n  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>\n  inline void\n  transform_inits_impl(const stan::io::var_context& context__, VecVar&\n                       vars__, std::ostream* pstream__ = nullptr) const {\n    using local_scalar_t__ = double;\n    stan::io::serializer<local_scalar_t__> out__(vars__);\n    int current_statement__ = 0;\n    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\n    // suppress unused var warning\n    (void) DUMMY_VAR__;\n    try {\n      current_statement__ = 1;\n      context__.validate_dims(\"parameter initialization\", \"theta1\", \"double\",\n        std::vector<size_t>{});\n      current_statement__ = 2;\n      context__.validate_dims(\"parameter initialization\", \"b\", \"double\",\n        std::vector<size_t>{});\n      current_statement__ = 3;\n      context__.validate_dims(\"parameter initialization\", \"theta2\", \"double\",\n        std::vector<size_t>{});\n      current_statement__ = 4;\n      context__.validate_dims(\"parameter initialization\", \"N\", \"double\",\n        std::vector<size_t>{static_cast<size_t>(M)});\n      int pos__ = std::numeric_limits<int>::min();\n      pos__ = 1;\n      local_scalar_t__ theta1 = DUMMY_VAR__;\n      current_statement__ = 1;\n      theta1 = context__.vals_r(\"theta1\")[(1 - 1)];\n      out__.write(theta1);\n      local_scalar_t__ b = DUMMY_VAR__;\n      current_statement__ = 2;\n      b = context__.vals_r(\"b\")[(1 - 1)];\n      out__.write(b);\n      local_scalar_t__ theta2 = DUMMY_VAR__;\n      current_statement__ = 3;\n      theta2 = context__.vals_r(\"theta2\")[(1 - 1)];\n      out__.write_free_lb(0, theta2);\n      Eigen::Matrix<local_scalar_t__,-1,1> N =\n        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(M, DUMMY_VAR__);\n      {\n        std::vector<local_scalar_t__> N_flat__;\n        current_statement__ = 4;\n        N_flat__ = context__.vals_r(\"N\");\n        current_statement__ = 4;\n        pos__ = 1;\n        current_statement__ = 4;\n        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {\n          current_statement__ = 4;\n          stan::model::assign(N, N_flat__[(pos__ - 1)],\n            \"assigning variable N\", stan::model::index_uni(sym1__));\n          current_statement__ = 4;\n          pos__ = (pos__ + 1);\n        }\n      }\n      out__.write_free_lb(0, N);\n    } catch (const std::exception& e) {\n      stan::lang::rethrow_located(e, locations_array__[current_statement__]);\n    }\n  }\n  inline void\n  get_param_names(std::vector<std::string>& names__, const bool\n                  emit_transformed_parameters__ = true, const bool\n                  emit_generated_quantities__ = true) const {\n    names__ = std::vector<std::string>{\"theta1\", \"b\", \"theta2\", \"N\"};\n    if (emit_transformed_parameters__) {\n      std::vector<std::string> temp{\"mu\", \"Sigma\"};\n      names__.reserve(names__.size() + temp.size());\n      names__.insert(names__.end(), temp.begin(), temp.end());\n    }\n    if (emit_generated_quantities__) {}\n  }\n  inline void\n  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool\n           emit_transformed_parameters__ = true, const bool\n           emit_generated_quantities__ = true) const {\n    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},\n                std::vector<size_t>{}, std::vector<size_t>{},\n                std::vector<size_t>{static_cast<size_t>(M)}};\n    if (emit_transformed_parameters__) {\n      std::vector<std::vector<size_t>>\n        temp{std::vector<size_t>{static_cast<size_t>(M)},\n             std::vector<size_t>{static_cast<size_t>(M),\n               static_cast<size_t>(M)}};\n      dimss__.reserve(dimss__.size() + temp.size());\n      dimss__.insert(dimss__.end(), temp.begin(), temp.end());\n    }\n    if (emit_generated_quantities__) {}\n  }\n  inline void\n  constrained_param_names(std::vector<std::string>& param_names__, bool\n                          emit_transformed_parameters__ = true, bool\n                          emit_generated_quantities__ = true) const final {\n    param_names__.emplace_back(std::string() + \"theta1\");\n    param_names__.emplace_back(std::string() + \"b\");\n    param_names__.emplace_back(std::string() + \"theta2\");\n    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {\n      param_names__.emplace_back(std::string() + \"N\" + '.' +\n        std::to_string(sym1__));\n    }\n    if (emit_transformed_parameters__) {\n      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {\n        param_names__.emplace_back(std::string() + \"mu\" + '.' +\n          std::to_string(sym1__));\n      }\n      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {\n        for (int sym2__ = 1; sym2__ <= M; ++sym2__) {\n          param_names__.emplace_back(std::string() + \"Sigma\" + '.' +\n            std::to_string(sym2__) + '.' + std::to_string(sym1__));\n        }\n      }\n    }\n    if (emit_generated_quantities__) {}\n  }\n  inline void\n  unconstrained_param_names(std::vector<std::string>& param_names__, bool\n                            emit_transformed_parameters__ = true, bool\n                            emit_generated_quantities__ = true) const final {\n    param_names__.emplace_back(std::string() + \"theta1\");\n    param_names__.emplace_back(std::string() + \"b\");\n    param_names__.emplace_back(std::string() + \"theta2\");\n    for (int sym1__ = 1; sym1__ <= M; ++sym1__) {\n      param_names__.emplace_back(std::string() + \"N\" + '.' +\n        std::to_string(sym1__));\n    }\n    if (emit_transformed_parameters__) {\n      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {\n        param_names__.emplace_back(std::string() + \"mu\" + '.' +\n          std::to_string(sym1__));\n      }\n      for (int sym1__ = 1; sym1__ <= (M + ((M * (M - 1)) / 2)); ++sym1__) {\n        param_names__.emplace_back(std::string() + \"Sigma\" + '.' +\n          std::to_string(sym1__));\n      }\n    }\n    if (emit_generated_quantities__) {}\n  }\n  inline std::string get_constrained_sizedtypes() const {\n    return std::string(\"[{\\\"name\\\":\\\"theta1\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"theta2\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"N\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(M) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"mu\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(M) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"Sigma\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(M) + \",\\\"cols\\\":\" + std::to_string(M) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\");\n  }\n  inline std::string get_unconstrained_sizedtypes() const {\n    return std::string(\"[{\\\"name\\\":\\\"theta1\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"theta2\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"N\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(M) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"mu\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(M) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"Sigma\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string((M + ((M * (M - 1)) /2))) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\");\n  }\n  // Begin method overload boilerplate\n  template <typename RNG> inline void\n  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,\n              Eigen::Matrix<double,-1,1>& vars, const bool\n              emit_transformed_parameters = true, const bool\n              emit_generated_quantities = true, std::ostream*\n              pstream = nullptr) const {\n    const size_t num_params__ = (((1 + 1) + 1) + M);\n    const size_t num_transformed = emit_transformed_parameters * ((M + (M *\n      M)));\n    const size_t num_gen_quantities = emit_generated_quantities * (0);\n    const size_t num_to_write = num_params__ + num_transformed +\n      num_gen_quantities;\n    std::vector<int> params_i;\n    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,\n             std::numeric_limits<double>::quiet_NaN());\n    write_array_impl(base_rng, params_r, params_i, vars,\n      emit_transformed_parameters, emit_generated_quantities, pstream);\n  }\n  template <typename RNG> inline void\n  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&\n              params_i, std::vector<double>& vars, bool\n              emit_transformed_parameters = true, bool\n              emit_generated_quantities = true, std::ostream*\n              pstream = nullptr) const {\n    const size_t num_params__ = (((1 + 1) + 1) + M);\n    const size_t num_transformed = emit_transformed_parameters * ((M + (M *\n      M)));\n    const size_t num_gen_quantities = emit_generated_quantities * (0);\n    const size_t num_to_write = num_params__ + num_transformed +\n      num_gen_quantities;\n    vars = std::vector<double>(num_to_write,\n             std::numeric_limits<double>::quiet_NaN());\n    write_array_impl(base_rng, params_r, params_i, vars,\n      emit_transformed_parameters, emit_generated_quantities, pstream);\n  }\n  template <bool propto__, bool jacobian__, typename T_> inline T_\n  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {\n    Eigen::Matrix<int,-1,1> params_i;\n    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);\n  }\n  template <bool propto__, bool jacobian__, typename T_> inline T_\n  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,\n           std::ostream* pstream = nullptr) const {\n    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);\n  }\n  inline void\n  transform_inits(const stan::io::var_context& context,\n                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*\n                  pstream = nullptr) const final {\n    std::vector<double> params_r_vec(params_r.size());\n    std::vector<int> params_i;\n    transform_inits(context, params_i, params_r_vec, pstream);\n    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),\n                 params_r_vec.size());\n  }\n  inline void\n  transform_inits(const stan::io::var_context& context, std::vector<int>&\n                  params_i, std::vector<double>& vars, std::ostream*\n                  pstream__ = nullptr) const {\n    vars.resize(num_params_r__);\n    transform_inits_impl(context, vars, pstream__);\n  }\n  inline void\n  unconstrain_array(const std::vector<double>& params_constrained,\n                    std::vector<double>& params_unconstrained, std::ostream*\n                    pstream = nullptr) const {\n    const std::vector<int> params_i;\n    params_unconstrained = std::vector<double>(num_params_r__,\n                             std::numeric_limits<double>::quiet_NaN());\n    unconstrain_array_impl(params_constrained, params_i,\n      params_unconstrained, pstream);\n  }\n  inline void\n  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,\n                    Eigen::Matrix<double,-1,1>& params_unconstrained,\n                    std::ostream* pstream = nullptr) const {\n    const std::vector<int> params_i;\n    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,\n                             std::numeric_limits<double>::quiet_NaN());\n    unconstrain_array_impl(params_constrained, params_i,\n      params_unconstrained, pstream);\n  }\n};\n}\nusing stan_model = model26fc174283a851_stan_model_namespace::model26fc174283a851_stan_model;\n#ifndef USING_R\n// Boilerplate\nstan::model::model_base&\nnew_model(stan::io::var_context& data_context, unsigned int seed,\n          std::ostream* msg_stream) {\n  stan_model* m = new stan_model(data_context, seed, msg_stream);\n  return *m;\n}\nstan::math::profile_map& get_stan_profile_data() {\n  return model26fc174283a851_stan_model_namespace::profiles__;\n}\n#endif"

$model_name
[1] "stan_model"

$model_code
[1] "data {\n  int<lower=0> M;\n  int Nstar[M];\n}\nparameters {\n  real theta1;\n  real b;\n  real<lower=0> theta2;\n  vector<lower=0>[M] N;\n}\ntransformed parameters {\n  vector[M] mu; // Mean vector\n  cov_matrix[M] Sigma; // Covariance matrix\n\n  mu = rep_vector(theta1, M);\n\n  // Compute Sigma\n  for (i in 1:M) {\n    for (j in 1:M) {\n      Sigma[i, j] = (theta2) * pow(1 + b, abs(i - j));\n    }\n  }\n\n}\n\nmodel {\n  // Priors\n  theta2 ~ inv_gamma(0.1, 0.1);\n  theta1 ~ normal(0, 10*sqrt(theta2));\n  b ~ uniform(-2, 0);\n\n  // Likelihood\n  log(N) ~ multi_normal(mu, Sigma);\n\n  for(i in 1:M){\n    Nstar[i] ~ poisson(N[i]);\n  }\n\n  }"
attr(,"model_name2")
[1] "stan_model"

> # compilation and loading
> stan_model = rstan::stan_model("../stan_model.stan")
> 
> ### number of iterations in simulation study
> niter = 500
> 
> ### parameters for MCMC and mcmcEM
> nsim = 1e+4
> nsim_em = 1e+3
> max_nsim_em = 2e+4
> maxit_em = 1e+3
> 
> ### sample size
> T = 100
> 
> 
> 
> ##### get true parameter values
> theta_case1 = c(2, 0.22, -0.22)
> theta_case2 = c(2, 0.22, -0.50)
> 
> 
> 
> ### parameter value for negative binomial (probability, if 0 then Poisson)
> prob = 0.5
> 
> 
> 
> 
> 
> ################## Simulation Study #####################
> 
> ##### parallel environment setup
> 
> ### get cluster
> cluster = parallel::makeCluster(24)
> 
> ### get true number of iterations according to cluster size
> niter = ceiling(niter / length(cluster)) * length(cluster)
> 
> ### export variables
> parallel::clusterExport(cl = cluster, varlist = ls(all.names = TRUE))
> 
> ### identify cores
> for (id_cluster in 1:length(cluster)) {
+   parallel::clusterExport(cl = cluster[id_cluster], "id_cluster")
+ }
> 
> ### create folder for reports file
> suppressWarnings(dir.create("./reports"))
> 
> ### open report file
> parallel::clusterEvalQ(
+   cl = cluster, sink(paste("./reports/report", id_cluster, ".txt", sep = ""))
+ )
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

[[4]]
NULL

[[5]]
NULL

[[6]]
NULL

[[7]]
NULL

[[8]]
NULL

[[9]]
NULL

[[10]]
NULL

[[11]]
NULL

[[12]]
NULL

[[13]]
NULL

[[14]]
NULL

[[15]]
NULL

[[16]]
NULL

[[17]]
NULL

[[18]]
NULL

[[19]]
NULL

[[20]]
NULL

[[21]]
NULL

[[22]]
NULL

[[23]]
NULL

[[24]]
NULL

> 
> ### set seed
> parallel::clusterSetRNGStream(cl = cluster)
> 
> 
> 
> ##### do iterations in parallel
> source("../SimStudy_negbinomModel_parexe.R")
> 
> 
> 
> ##### parallel environment shut down
> 
> ### close report file
> parallel::clusterEvalQ(cl = cluster, sink())
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

[[4]]
NULL

[[5]]
NULL

[[6]]
NULL

[[7]]
NULL

[[8]]
NULL

[[9]]
NULL

[[10]]
NULL

[[11]]
NULL

[[12]]
NULL

[[13]]
NULL

[[14]]
NULL

[[15]]
NULL

[[16]]
NULL

[[17]]
NULL

[[18]]
NULL

[[19]]
NULL

[[20]]
NULL

[[21]]
NULL

[[22]]
NULL

[[23]]
NULL

[[24]]
NULL

> 
> ### leave cluster
> parallel::stopCluster(cl = cluster)
There were 40 warnings (use warnings() to see them)
There were 40 warnings (use warnings() to see them)
There were 45 warnings (use warnings() to see them)
There were 43 warnings (use warnings() to see them)
There were 42 warnings (use warnings() to see them)
There were 45 warnings (use warnings() to see them)
There were 42 warnings (use warnings() to see them)There were 40 warnings (use warnings() to see them)

There were 39 warnings (use warnings() to see them)
There were 42 warnings (use warnings() to see them)
There were 41 warnings (use warnings() to see them)
There were 43 warnings (use warnings() to see them)
There were 41 warnings (use warnings() to see them)
There were 41 warnings (use warnings() to see them)
There were 42 warnings (use warnings() to see them)
There were 40 warnings (use warnings() to see them)
There were 43 warnings (use warnings() to see them)
There were 40 warnings (use warnings() to see them)
There were 42 warnings (use warnings() to see them)
There were 40 warnings (use warnings() to see them)
There were 42 warnings (use warnings() to see them)
There were 47 warnings (use warnings() to see them)
There were 38 warnings (use warnings() to see them)
There were 40 warnings (use warnings() to see them)
> 
> 
> 
> ##### merge parallel executions
> source("../SimStudy_negbinomModel_mergepar.R")
> 
> 
> 
> 
> 
> ################################### Closure ###################################
> save(
+   list = ls(), file = paste("SimStudy_negbinomModel_T", T, ".RData", sep = "")
+ )
> 
> proc.time()
     user    system   elapsed 
  115.127     7.942 86012.667 
