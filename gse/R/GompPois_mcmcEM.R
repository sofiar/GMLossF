#' @title Gompertz Model with Poisson Sampling Error: Markov Chain Monte Carlo
#'  Expectation Maximization Algorithm

#' @description
#' Computation of the MLE for Gompertz model with Poisson sampling error
#'  distribution

#' @usage
#' GompPois_mcmcEM = function(Nstar, maxit = 1e+3,
#'                             abstol = sqrt(.Machine$double.eps),
#'                             max_nsim = 1e+5, nsim = 1e+4,
#'                             starter = NULL, verbose = +Inf)

#' @details
#' This function computes the MLE for the following model:
#'  \deqn{
#'  N^\star_t | N_t \sim \mathrm{Poisson}(N_t) \, , \\
#'  N_t = \exp(Z_t) \, , \\
#'  Z_t = a + (1 + b) Z_{t - 1} + \varepsilon_t \, , \\
#'  \varepsilon_t \overset{i.i.d.}{\sim} N(0, \sigma^2) \, .
#'  }
#'
#' A different parametrization is used, say:
#'  \deqn{
#'  \theta_1 = -\frac{a}{b} \, , \, \theta_2 = -\frac{\sigma^2}{b(2 + b)}
#'  \, ,
#'  }
#' which implies
#' \deqn{
#'  Z_1, Z_2, ..., Z_T \sim N_T ( \theta_1 1_T, \theta_2 \bar{\Sigma})  \, \\
#'  \bar{\Sigma}_{ij} = (1 + b ) ^ {\vert i - j \vert} \, .
#' }
#' The following scheme is used
#' \itemize{
#'  \item for \eqn{t = 1, 2, ..., T}:
#'        sample \eqn{Z_t \vert N^\star_t, Z_{-t}, b, \theta_1, \theta_2}
#'        (using acceptance-rejection) and ...
#'
#'  \item maximize the log-likelihood by taking ...
#' }
#'
#' \code{starter} must be a list with the following structure:
#' \code{starter$theta1}, \code{starter$theta2}, \code{starter$b}, or
#' \code{NULL}. In the latter case the starting point is generated by method of
#' moments.

#' @references
#' [INSERT REFERENCE]

#' @param Nstar The vector of the data.
#' @param maxit The maximum number of iterations.
#' @param abstol The absolute convergence tolerance.
#' @param max_nsim The maximum number of complete scans for MCMC step.
#' @param nsim The initial number of complete scans for MCMC step.
#' @param starter The list providing the starter point.
#' @param verbose The period for printing status of the chain.
#' @return MLE estimates.

#' @export
GompPois_mcmcEM = function(
  Nstar, maxit = 1e+3, abstol = 1e-3,
  max_nsim = 2e+4, nsim = 1e+3, starter = NULL, verbose = +Inf
) {

  ### print start time if required
  if (!is.infinite(verbose)) {
    print(paste(
      "GompPois_mcmcEM: start time at ", Sys.time(),
      " | maxit ", maxit, " | max_nsim ", max_nsim, " | initial nsim ", nsim,
      sep = ""
    ))
  }

  ### check verbose
  if (verbose == 0) verbose = nsim + 1




  ########## initialization

  ##### get starting values

  ### if starting values are not provided then use method of moments
  if (is.null(starter)) {
    starter = GompPois_MoM(Nstar)
    # check if estimated values belong to the support of the parameters
    if (starter$theta2 < 0.01) starter$theta2 = 0.01
    if (starter$b > -0.01) starter$b = -0.01
    if (starter$b < -0.99) starter$b = -0.99
  }

  ### initialize parameter values
  theta1 = starter$theta1
  theta2 = starter$theta2
  b = starter$b



  ### sample size
  T = length(Nstar)

  ### initialize counter of iteration
  iit = 0




  ########## run the optimization
  while (TRUE) {

    ##### Expectation step

    ### run mcmc for sampling Z
    sample_z = GompPois_mcmc_Z(
      nsim = nsim, T = T, Nstar = Nstar,
      theta1 = theta1, theta2 = theta2, b = b
    )



    ##### Maximization step

    ### run optim
    new_theta = optim(
      par = c(b, theta1, theta2),
      fn = function(x) {
        -mean(logGauss_kernel_theta(
          z = sample_z, b = x[1], theta1 = x[2], theta2 = x[3], T = T
        ))
      },
      method = "L-BFGS-B",
      lower = c(-1.999, -Inf, 0.001), upper = c(-0.001, +Inf, +Inf)
    )$par



    ##### check precision of mcmc

    ### get differences of Q function
    diff_Qfun = logGauss_kernel_theta(
      z = sample_z, b = new_theta[1], theta1 = new_theta[2],
      theta2 = new_theta[3], T = T
    ) - logGauss_kernel_theta(
      z = sample_z, b = b, theta1 = theta1, theta2 = theta2, T = T
    )

    ### lower CI at 0.10
    ctrl_increase = 0 < mean(diff_Qfun) -
      qnorm(p = 0.95) * sqrt(var(diff_Qfun) / length(diff_Qfun))

    ### if Q function increases then accept new values for theta
    if (ctrl_increase) {

      # increase by 1 the counter of iterations
      iit = iit + 1

      # compute step-size
      step_size = sqrt(
        (b - new_theta[1])^2 + (theta1 - new_theta[2])^2 +
          (theta2 - new_theta[3])^2
      )

      # get new values of parameters
      b = new_theta[1]
      theta1 = new_theta[2]
      theta2 = new_theta[3]

      # print status of the optimization
      if (iit %% verbose == 0) {
        print(paste(
          "iteration ", iit, " completed at time ", Sys.time(),
          " | maxit ", maxit, " | max_nsim ", max_nsim, " | current nsim ",
          nsim, " | current values: theta1 ", format(theta1, digits = 4),
          ", theta2 ", format(theta2, digits = 4), " and b ",
          format(b, digits = 4), " | step size ", step_size, sep = ""
        ))
      }

      # check convergence or end of runs
      if (step_size <= abstol || iit >= maxit) {
        break
      }

      ### if Q function likely does not increase then doubled nsim or stop
    } else {

      # double nsim
      nsim = 2 * nsim

      # check if nsim limit is reached
      if (nsim > max_nsim) {
        if (!is.infinite(verbose)) {
          print(paste(
            "iteration ", iit + 1, " reached max_nsim at time ", Sys.time(),
            ", thus STOP the algorithm",
            " | maxit ", maxit, " | max_nsim ", max_nsim, " | current nsim ",
            nsim / 2, " | step_size ", step_size, sep = ""
          ))
        }
        break
      }

    }

  }




  ########## compute inverse of Fisher information matrix

  ### check if nsim limit has not been reached
  if (!nsim > max_nsim) nsim = 2 * nsim

  ### get values of alternative parametrization
  a = - theta1 * b
  sigmaSq = - theta2 * b * (2 + b)

  ### run mcmc for sampling Z
  sample_z = GompPois_mcmc_Z(
    nsim = nsim, T = T, Nstar = Nstar,
    theta1 = theta1, theta2 = theta2, b = b
  )

  ### initialize negative Hessian and score for first component
  Score_L1 = c(0, 0, 0)
  negHess_L1 = matrix(0, nrow = 3, ncol = 3)
  negHess_L1[1, 1] = 1 / theta2

  ### initialize negative Hessian for second component (alternative parameters)
  negHess_Lm1_alt = matrix(0, nrow = 3, ncol = 3)
  negHess_Lm1_alt[1, 1] = (T - 1) / sigmaSq

  ### compute Jacobian from (a, sigmaSq, b) to (theta1, theta2, b)
  Jacob = matrix(
    data = c(
      -b, 0, -theta1,
      0, -b * (2 + b), -2 * (1 + b) * theta2,
      0, 0, 1
    ), nrow = 3, ncol = 3, byrow = TRUE
  )

  ### initialize negative Hessian and cross product of score
  negHess = array(0, dim = c(3, 3, nsim))
  crossScore = array(0, dim = c(3, 3, nsim))



  ##### compute negative Hessian and cross-product for every sample of Z
  for (insim in 1:nsim) {

    ### first component
    Score_L1[1] = (sample_z[1, insim] - theta1) / theta2
    Score_L1[2] = -0.5 / theta2 + 0.5 * (
      (sample_z[1, insim] - theta1) / theta2
    )^2
    negHess_L1[1, 2] = negHess_L1[2, 1] = Score_L1[1]
    negHess_L1[2, 2] = Score_L1[2] / theta2

    ### compute useful quantities
    diff_mean = sum(
      sample_z[2:T, insim] - a - (1 + b) * sample_z[1:(T - 1), insim]
    )
    diffSq_mean = sum(
      (sample_z[2:T, insim] - a - (1 + b) * sample_z[1:(T - 1), insim])^2
    )
    diffZ_mean = sum(
      sample_z[1:(T - 1), insim] *
        (sample_z[2:T, insim] - a - (1 + b) * sample_z[1:(T - 1), insim])
    )
    Z_sum = sum(sample_z[1:(T - 1), insim])
    Zsq_sum = sum(sample_z[1:(T - 1), insim]^2)

    ### compute cross-product of score
    de_a_sigmaSq_b = c(
      diff_mean / sigmaSq,
      - 0.5 * (T - 1) / sigmaSq + 0.5 * diffSq_mean / sigmaSq^2,
      diffZ_mean / sigmaSq
    )
    crossScore[, , insim] = tcrossprod(Score_L1 + c(
      de_a_sigmaSq_b[-3] * diag(Jacob)[-3],
      sum(de_a_sigmaSq_b * Jacob[, 3])
    ))

    ### compute negative Hessian
    negHess_Lm1_alt[1, 2] = negHess_Lm1_alt[2, 1] = de_a_sigmaSq_b[1] / sigmaSq
    negHess_Lm1_alt[1, 3] = negHess_Lm1_alt[3, 1] =  Z_sum / sigmaSq
    negHess_Lm1_alt[2, 2] = diffSq_mean / sigmaSq^3 - 0.5 * (T - 1) / sigmaSq^2
    negHess_Lm1_alt[2, 3] = negHess_Lm1_alt[3, 2] = diffZ_mean / sigmaSq^2
    negHess_Lm1_alt[3, 3] = Zsq_sum / sigmaSq
    negHess[, , insim] = negHess_L1 + quad_form(negHess_Lm1_alt, Jacob)

  }



  ### compute inverse of Fisher information matrix
  invFIM = chol2inv(chol(
    rowMeans(negHess, dims = 2) - rowMeans(crossScore, dims = 2)
  ))




  ### print end time if required
  if (!is.infinite(verbose)) {
    print(paste(
      "GompPois_mcmcEM: end time at ", Sys.time(),
      " | maxit ", maxit, " | max_nsim ", max_nsim, " | final nsim ", nsim,
      sep = ""
    ))
  }

  ### return results
  return(list(
    par = c(theta1 = theta1, theta2 = theta2, b = b),
    invFIM = invFIM
  ))

}