#' @title Gompertz Model with Poisson Sampling Error: Markov Chain Monte Carlo
#'  Expectation Maximization Algorithm

#' @description
#' Computation of the MLE for Gompertz model with Poisson sampling error
#'  distribution

#' @usage
#' GompPois_mcmcEM = function(Nstar, maxit = 1e+3,
#'                             abstol = sqrt(.Machine$double.eps),
#'                             max_nsim = 1e+5, nsim = 1e+4,
#'                             starter = NULL, verbose = +Inf)

#' @details
#' This function computes the MLE for the following model:
#'  \deqn{
#'  N^\star_t | N_t \sim \mathrm{Poisson}(N_t) \, , \\
#'  N_t = \exp(Z_t) \, , \\
#'  Z_t = a + (1 + b) Z_{t - 1} + \varepsilon_t \, , \\
#'  \varepsilon_t \overset{i.i.d.}{\sim} N(0, \sigma^2) \, .
#'  }
#'
#' A different parametrization is used, say:
#'  \deqn{
#'  \theta_1 = -\frac{a}{b} \, , \, \theta_2 = -\frac{\sigma^2}{b(2 + b)}
#'  \, ,
#'  }
#' which implies
#' \deqn{
#'  Z_1, Z_2, ..., Z_T \sim N_T ( \theta_1 1_T, \theta_2 \bar{\Sigma})  \, \\
#'  \bar{\Sigma}_{ij} = (1 + b ) ^ {\vert i - j \vert} \, .
#' }
#' The following scheme is used
#' \itemize{
#'  \item for \eqn{t = 1, 2, ..., T}:
#'        sample \eqn{Z_t \vert N^\star_t, Z_{-t}, b, \theta_1, \theta_2}
#'        (using acceptance-rejection) and ...
#'
#'  \item maximize the log-likelihood by taking ...
#' }
#'
#' \code{starter} must be a list with the following structure:
#' \code{starter$theta1}, \code{starter$theta2}, \code{starter$b}, or
#' \code{NULL}. In the latter case the starting point is generated by method of
#' moments.

#' @references
#' [INSERT REFERENCE]

#' @param Nstar The vector of the data.
#' @param maxit The maximum number of iterations.
#' @param abstol The absolute convergence tolerance.
#' @param max_nsim The maximum number of complete scans for MCMC step.
#' @param nsim The initial number of complete scans for MCMC step.
#' @param starter The list providing the starter point.
#' @param verbose The period for printing status of the chain.
#' @return MLE estimates.

#' @export
GompPois_mcmcEM = function(
  Nstar, maxit = 1e+3, abstol = sqrt(.Machine$double.eps),
  max_nsim = 1e+5, nsim = 1e+4, starter = NULL, verbose = +Inf
) {

  #--------------
  sub_GompPois_mcmc_Z = function(nsim, Nstar, theta1, theta2, b) {

    mcmc_sample = matrix(nrow = T, ncol = nsim)
    a = -b * theta1
    sigmaSq = -b * (2 + b) * theta2

    # sample Z from importance density
    IS_obj = c(GompPois_likelihood(
      Nstar, theta1 = theta1, theta2 = theta2, b = b,
      nsim = 1e+4, log = TRUE, details = TRUE
    ))
    Z = IS_obj$Z[, sample(
      c(1:1e+4), size = 1, replace = FALSE, prob = IS_obj$normWeights
    )]

    for (insim in 1:nsim) {
      for (t in 1:T) {

        if (t == 1) {
          mu = (theta1 * sigmaSq + (1 + b) * (Z[2] - a) * theta2) / (
            sigmaSq + (1 + b)^2 * theta2
          )
          tauSq = sigmaSq * theta2 / (sigmaSq + (1 + b)^2 * theta2)
        } else if (t == T) {
           mu = a + (1 + b) * Z[T-1]
           tauSq = sigmaSq
        } else {
           mu = (a + (1 + b) * (Z[t+1] + Z[t-1] - a)) / (1 + (1 + b)^2)
          tauSq = sigmaSq / (1 + (1 + b)^2)
        }

        xi = Nstar[t] * tauSq + mu - lambertW_expArg(
          log(tauSq) + Nstar[t] * tauSq + mu
        )

        logC = -exp(xi) + xi * Nstar[t] - 0.5 / tauSq * (xi - mu)^2

        while (TRUE) {
          x = xi + sqrt(tauSq) * rnorm(100)
          check = -rexp(100) <= -exp(x) + x * Nstar[t] -
            0.5 / tauSq * (x - mu)^2 +
            0.5 / tauSq * (x - xi)^2 -
            logC
          if (sum(check) > 0) {
            Z[t] = x[check][1]
            break
          }
        }

      }
      mcmc_sample[, insim] = Z
    }

    return(mcmc_sample)
  }
  #--------------


  ###############--------------- function script

  ### print start time if required
  if (!is.infinite(verbose)) {
    print(paste(
      "GompPois_mcmcEM: start time at ", Sys.time(),
      " | maxit ", maxit, " | max_nsim ", max_nsim, " | initial nsim ", nsim,
      sep = ""
    ))
  }

  ### check verbose
  if (verbose == 0) verbose = nsim + 1




  ########## initialization

  ##### get starting values

  ### if starting values are not provided then use method of moments
  if (is.null(starter)) {
    starter = GompPois_MoM(Nstar)
    # check if estimated values belong to the support of the parameters
    if (starter$theta2 < 0.01) starter$theta2 = 0.01
    if (starter$b > -0.01) starter$b = -0.01
    if (starter$b < -0.99) starter$b = -0.99
  }

  ### initialize parameter values
  theta1 = starter$theta1
  theta2 = starter$theta2
  b = starter$b



  ### sample size
  T = length(Nstar)

  ### initialize inverse of B
  invB = matrix(0, nrow = T, ncol = T)

  ### initialize the current value of the Q function
  curr_Qval = -Inf

  ### initialize control for decreasing of Q function
  Qval_decreased = FALSE

  ### initialize counter of iteration
  iit = 0




  ########## run the optimization
  while (TRUE) {

    ##### Expectation step

    ### run mcmc for computing quantities of interest for Z
    sample_z = sub_GompPois_mcmc_Z(nsim, Nstar, theta1, theta2, b)

    ### extract values
    # mean of Z
    mean_z = rowMeans(sample_z)
    # variance of Z
    var_z = cov(t(sample_z))
    # mean of exponential
    meanExp_z = rowMeans(exp(sample_z))



    ##### Maximization step

    ### get negative logit transformation of b
    beta = log(-b / (1 + b))

    ### run optim
    opt_tmp = tryCatch(
      expr = optim(
        par = c(theta1, theta2, beta),
        fn = function(x) {

          # get theta1
          theta1 = x[1]

          # get theta2 (always positive)
          theta2 = abs(x[2])

          # get b
          b = -1 / (1 + exp(-x[3]))

          # get inverse of B
          invB[1, 1] = 1
          invB[1, 2] = -(1 + b)
          invB[2, 1] = -(1 + b)
          invB[T, T] = 1
          for (t in 2:(T-1)) {
            invB[t, t] = 1 + (1 + b)^2
            invB[t, t + 1] = -(1 + b)
            invB[t + 1, t] = -(1 + b)
          }
          invB = invB / (1 - (1 + b)^2)

          # get the value
          output = -0.5 * T * log(theta2) - 0.5 * (T - 1) *
            log(-b * (2 + b)) - 0.5 / theta2 * (
            sum(invB * var_z) +
              colSums(crossprod(invB, Conj(mean_z)) * mean_z) -
              2 * theta1 * sum(c(rowSums(invB)) * mean_z) +
              theta1^2 * sum(invB)
          )

          # return the result
          return(-output)

        },
        method = "BFGS"
      ),
      error = function(err) return("err")
    )

    if (opt_tmp[1] == "err") {
      opt_tmp = optim(
        par = c(theta1, theta2, beta),
        fn = function(x) {

          # get theta1
          theta1 = x[1]

          # get theta2 (always positive)
          theta2 = abs(x[2])

          # get b
          b = -1 / (1 + exp(-x[3]))

          # get inverse of B
          invB[1, 1] = 1
          invB[1, 2] = -(1 + b)
          invB[2, 1] = -(1 + b)
          invB[T, T] = 1
          for (t in 2:(T - 1)) {
            invB[t, t] = 1 + (1 + b)^2
            invB[t, t + 1] = -(1 + b)
            invB[t + 1, t] = -(1 + b)
          }
          invB = invB / (1 - (1 + b)^2)

          # get the value
          output = -0.5 * T * log(theta2) - 0.5 * (T - 1) *
            log(-b * (2 + b)) - 0.5 / theta2 * (
            sum(invB * var_z) +
              colSums(crossprod(invB, Conj(mean_z)) * mean_z) -
              2 * theta1 * sum(c(rowSums(invB)) * mean_z) +
              theta1^2 * sum(invB)
          )

          # return the result
          return(-output)

        },
        method = "Nelder-Mead"
      )
    }



    ##### check precision of mcmc

    ### get new value of Q function
    new_Qval = -opt_tmp$value + sum(-meanExp_z + mean_z * Nstar)

    ### if Q function does not increase then doubled nsim and alert control
    if (new_Qval - curr_Qval < 0) {
      Qval_decreased = TRUE
      # otherwise reset control
    } else {
      Qval_decreased = FALSE
    }

    ### get new values of parameters
    theta1 = opt_tmp$par[1]
    theta2 = abs(opt_tmp$par[2])
    b = -1 / (1 + exp(-opt_tmp$par[3]))



    ##### check if Q function decreased then reset else check convergence

    if (Qval_decreased) {
      ### and double nsim if Q function decreased
      nsim = 2 * nsim

      if (nsim <= max_nsim) {
        ### reset curr_Qval
        curr_Qval = -Inf
      } else {
        if (!is.infinite(verbose)) {
          print(paste(
            "iteration ", iit + 1, " reached max_nsim at time ", Sys.time(),
            ", thus STOP the algorithm",
            " | maxit ", maxit, " | max_nsim ", max_nsim, " | current nsim ",
            nsim, sep = ""
          ))
        }
        break
      }

    } else {
      ### increase by 1 the counter of iterations
      iit = iit + 1

      ### print status of the optimization
      if (iit %% verbose == 0) {
        print(paste(
          "iteration ", iit, " completed at time ", Sys.time(),
          " | maxit ", maxit, " | max_nsim ", max_nsim, " | current nsim ",
          nsim, sep = ""
        ))
      }

      if (new_Qval - curr_Qval <= abstol || iit >= maxit) {
        break
      } else {
        curr_Qval = new_Qval
      }
    }

  }




  ### print end time if required
  if (!is.infinite(verbose)) {
    print(paste(
      "GompPois_mcmcEM: end time at ", Sys.time(),
      " | maxit ", maxit, " | max_nsim ", max_nsim, " | final nsim ", nsim,
      sep = ""
    ))
  }

  ### return results
  return(c(theta1, theta2, b))

}