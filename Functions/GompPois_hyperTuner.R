
source("./Functions/GompPois_Bfixed_quasiGibbs.R")

############### function
GompPois_hyperTuner = function(
  Nstar, maxit = 1e+3, abstol = sqrt(.Machine$double.eps),
  nsim = 1e+4, starter = NULL, verbose = +Inf
) {

  # Nstar is the vector of the data, say Nstar_t, t = 1,2,...,T;
  # nsim is the number of simulations for MCMC step;
  # starter is a list providing the starter point;
  # verbose is the period for printing status of the chain.

  # starter must be a list with the following structure:
  # starter$theta1, starter$theta2, starter$b, or NULL. In the
  # latter case the starting point is generated by method of moments.

  #--------------
#   sub_Gomp_mcmc_Z = function(nsim, Nstar, theta1, theta2, b) {

#     mcmc_sample = matrix(nrow = T, ncol = nsim)
#     a = -b * theta1
#     sigmaSq = -b * (2 + b) * theta2

#     # sample Z from importance density
#     IS_obj = c(GompPois_likelihood(
#       Nstar, theta1 = theta1, theta2 = theta2, b = b,
#       nsim = 1e+4, log = TRUE, details = TRUE
#     ))
#     Z = IS_obj$Z[, sample(
#       c(1:1e+4), size = 1, replace = FALSE, prob = IS_obj$normWeights
#     )]

#     for (insim in 1:nsim) {
#       for (t in 1:T) {

#         if (t == 1) {
#           mu = (theta1 * sigmaSq + (1 + b) * (Z[2] - a) * theta2) / (
#             sigmaSq + (1 + b)^2 * theta2
#           )
#           tauSq = sigmaSq * theta2 / (sigmaSq + (1 + b)^2 * theta2)
#         } else if (t == T) {
#            mu = a + (1 + b) * Z[T-1]
#            tauSq = sigmaSq
#         } else {
#            mu = (a + (1 + b) * (Z[t+1] + Z[t-1] - a)) / (1 + (1 + b)^2)
#           tauSq = sigmaSq / (1 + (1 + b)^2)
#         }

#         xi = Nstar[t] * tauSq + mu - lambertW_expArg(
#           log(tauSq) + Nstar[t] * tauSq + mu
#         )

#         logC = -exp(xi) + xi * Nstar[t] - 0.5 / tauSq * (xi - mu)^2

#         while (TRUE) {
#           x = xi + sqrt(tauSq) * rnorm(100)
#           check = -rexp(100) <= -exp(x) + x * Nstar[t] -
#             0.5 / tauSq * (x - mu)^2 +
#             0.5 / tauSq * (x - xi)^2 -
#             logC
#             if (sum(check) > 0) {
#             Z[t] = x[check][1]
#             break
#           }
#         }

#       }
#       mcmc_sample[, insim] = Z
#     }
#     mean_z = rowMeans(mcmc_sample)
#     var_z = cov(t(mcmc_sample))
#     meanExp_z = rowMeans(exp(mcmc_sample))

#     return(list(
#       mean_z = mean_z,
#       var_z = var_z,
#       meanExp_z = meanExp_z
#     ))
#   }
  #--------------
  diagQuad_form = function(M, x) colSums(crossprod(M, x) * x)

  ###############--------------- function script

  ### print start time if required
  if (!is.infinite(verbose)) {
    print(paste("GompPois_hyperTuner: start time at ", Sys.time(), sep = ""))
  }

  ### check verbose
  if (verbose == 0) verbose = nsim + 1




  ########## initialization

  ##### get starting values

  ### if starting values are not provided then use method of moments
  if (is.null(starter)) {
    starter = GompPois_MoM(Nstar)
    # check if estimated values belong to the support of the parameters
    if(starter$theta2 < 0.01) starter$theta2 = 0.01
    if(starter$b > -0.01) starter$b = -0.01
    if(starter$b < -0.99) starter$b = -0.99
  }

  ### initialize b and hyperparameter values
  b = starter$b
  zeta1 = starter$theta1
  zeta2 = (2-2*(1+b))/sqrt(1-(1+b)^2)
  psi2 = 2*starter$theta2^2
  psi1 = psi2/starter$theta2  


  ### sample size
  T = length(Nstar)

  ### initialize inverse of B
  invB = matrix(0, nrow = T, ncol = T)

  ### initialize the current value of the Q function
  curr_Qval = -Inf

  ### initialize counter of iteration
  iit = 0




  ########## run the optimization
  while (TRUE) {

    ##### Expectation step

    ### run mcmc for computing quantities of interest for Z
    sample_z = GompPois_Bfixed_quasiGibbs(nsim, Nstar, psi1, psi2, zeta1, 
                                          zeta2, b)
          
    ##### Maximization step

    ### get negative logit transformation of b
    beta = log(-b / (1 + b))

    ### run optim
    opt_tmp = tryCatch(
      expr = optim(
        par = c(zeta1, zeta2, psi1, psi2, beta),
        fn = function(x) {

          # get zeta1
          zeta1 = x[1]

          # get zeta2 (always positive)
          zeta2 = abs(x[2])

          # get psi1 (always positive)
          psi1 = abs(x[3])

          # get psi2 (always positive)
          psi2 = abs(x[4])

          # get b
          b = -1 / (1 + exp(-x[5]))

          # get inverse of B
          invB[1, 1] = 1
          invB[1, 2] = -(1 + b)
          invB[2, 1] = -(1 + b)
          invB[T, T] = 1
          for (t in 2:(T-1)) {
            invB[t, t] = 1 + (1 + b)^2
            invB[t, t + 1] = -(1 + b)
            invB[t + 1, t] = -(1 + b)
          }
          invB = invB / (1 - (1 + b)^2)

          # get useful quantities
          commonFactor = 1 + zeta2 * sum(invB)
          rowSums_invB = c(rowSums(invB)) # it is B^-1 %*% 1_T
          
          # get log-determinant
          log_det = commonFactor * (1 - (1 + b)^2)^(T - 1)

          # get inverse scale
          inv_scale = invB - zeta2 * tcrossprod(rowSums_invB) / commonFactor

          # get the value
          output = sum(
            lgamma(psi1 + 0.5 * T) - lgamma(psi1) - 0.5 * T * log(psi2) -
                    0.5 * log_det - (psi1 + 0.5 * T) * log(
                      1 + 0.5 / psi2 * diagQuad_form(
                        inv_scale, sample_z - psi1
                      )
                    )
          )

          # return the result
          return(-output)

        },
        method = "BFGS"
      ),
      error = function(err) return("err")
    )

    if (opt_tmp[1] == "err") {
      opt_tmp = optim(
        par = c(zeta1, zeta2, psi1, psi2, beta),
        fn = function(x) {

          # get zeta1
          zeta1 = x[1]

          # get zeta2 (always positive)
          zeta2 = abs(x[2])

          # get psi1 (always positive)
          psi1 = abs(x[3])

          # get psi2 (always positive)
          psi2 = abs(x[4])

          # get b
          b = -1 / (1 + exp(-x[5]))

          # get inverse of B
          invB[1, 1] = 1
          invB[1, 2] = -(1 + b)
          invB[2, 1] = -(1 + b)
          invB[T, T] = 1
          for (t in 2:(T-1)) {
            invB[t, t] = 1 + (1 + b)^2
            invB[t, t + 1] = -(1 + b)
            invB[t + 1, t] = -(1 + b)
          }
          invB = invB / (1 - (1 + b)^2)

          # get useful quantities
          commonFactor = 1 + zeta2 * sum(invB)
          rowSums_invB = c(rowSums(invB)) # it is B^-1 %*% 1_T
          
          # get log-determinant
          log_det = commonFactor * (1 - (1 + b)^2)^(T - 1)

          # get inverse scale
          inv_scale = invB - zeta2 * tcrossprod(rowSums_invB) / commonFactor

          # get the value
          output = sum(
            lgamma(psi1 + 0.5 * T) - lgamma(psi1) - 0.5 * T * log(psi2) -
                    0.5 * log_det - (psi1 + 0.5 * T) * log(
                      1 + 0.5 / psi2 * diagQuad_form(
                        inv_scale, sample_z - psi1
                      )
                    )
          )

          # return the result
          return(-output)

        },
        method = "Nelder-Mead"
      )
    }



    ##### get new values of parameters and check convergence

    ### increase by 1 the counter of iterations
    iit = iit + 1

    ### get parameters
    zeta1 = opt_tmp$par[1]
    zeta2 = abs(opt_tmp$par[2])
    psi1 = abs(opt_tmp$par[3])
    psi2 = abs(opt_tmp$par[4])
    b = -1 / (1 + exp(-opt_tmp$par[5]))

    ### get new value of Q function
    new_Qval = -opt_tmp$value + sum(-rowMeans(exp(sample_z)) + rowMeans(sample_z) * Nstar)

    ### print status of the optimization
    if (iit %% verbose == 0) {
      print(paste(
        "iteration ", iit, " (maximum is ", maxit, ") completed at time ",
        Sys.time()," with Q function value = " , new_Qval, sep = ""
      ))
    }

    if (new_Qval - curr_Qval <= abstol || iit >= maxit) {
      break
    } else {
      curr_Qval = new_Qval
    }

  }




  ### print end time if required
  if (!is.infinite(verbose)) {
    print(paste("GompPois_hyperTuner: end time at ", Sys.time(), sep = ""))
  }

  ### return results
  return(c(zeta1, zeta2, psi1, psi2, b))

}





############### appendix

if (FALSE) { # appendix script is not run

  # debugging
  {
    rm(list = ls()); gc(); cat("\14")
    source("./Functions/GompPois_hyperTuner.R")
    source("./Functions/Extrafunctions.R")
    set.seed(1994)
    nsim = 1e+4
    T = 50
    theta1 = 1.9244
    theta2 = 0.4726 ^ 2 # that is 0.2233508
    b = -0.24 # -0.8

    Nstar = GompPois_simulate(T, theta1 = theta1, theta2 = theta2, b = b)
    rm(list = c("T", "theta1", "theta2", "b"))

    maxit = 1000
    abstol =  sqrt(.Machine$double.eps)
    starter = NULL
    verbose = 100
    nsim = 1e+4
    start_time = Sys.time()
 
    res = GompPois_hyperTuner(Nstar, maxit = maxit, abstol = abstol ,
           nsim = nsim, starter = starter, verbose = verbose )
    
    end_time = Sys.time()
  }

  #difftime(end_time, start_time)

  res[4]/res[3]

  
  ###############

}