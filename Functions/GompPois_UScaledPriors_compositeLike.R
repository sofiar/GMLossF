################################################################################
#
# Gompertz Model with Poisson Sampling Error: Markov Chain Monte Carlo
#  Posterior Simulation Using Quasi Gibbs Sampler
#
################################################################################


############### description
# This function samples from the posterior distribution of the following model:
#
#           Nstar_t | N_t ~ Poisson(N_t)
#           N_t = exp(Z_t)
#           Z_t = a + (1 + b) Z_{t - 1} + eps_t
#           eps_t ~iid Gauss(0, sigmaSq)
#
# It is used an alternative parametrization, that is:
#
#     theta1 = - a / b
#     theta2 = - sigmaSq / (b * (2 + b))
#     beta = 1 / (1 + exp(b))
#
# which implies
#
#     Z_1, Z_2, ..., Z_T ~ Gauss_T ( theta1 1_T, theta2 SigmaBar)
#     SigmaBar_ij = (1 + b ) ^ abs(i - j)
#
# the priors are
#
#     beta ~ cauchy(0, c)
#     theta2 ~ invlomax(phi1, phi2)
#     theta1 | theta2 ~ student-t(nu, zeta1, zeta2 * theta2)
#
# The general Bayesin approach is used; in particular, the composite likelihood
# method is used. Therefore, the following Metropolis algoritihm is used
#
#     (1) sample V, W, U | theta1, theta2, beta
#         (1.1) sample V | beta (posterior of a logistic Kolmogorov)
#         (1.2) sample U | theta2 (gamma)
#         (1.3) sample W | theta1, theta2 (inverse gamma)
#
#     (2) sample theta1, theta2, beta | V, W, U using Metropolis alogorithm

# source("extraFunctions.R")


Rcpp::sourceCpp('./Functions/GompPois_composite_likelihood.cpp')
source("./Functions/GompPois_likelihood.R")

############### function
GompPois_UScaledPriors_compositeLike = function(
  nsim, Nstar, phi1, phi2, nu, zeta1, zeta2, c,
  Omega, starter = NULL, burn = 1, thin = 1, verbose = +Inf
) {

  # nsim is the number of simulations to be stored;
  # Nstar is the vector of the data, say Nstar_t, t = 1,2,...,T;
  # phi1, phi2, nu, zeta1, zeta2, c are the prior parameters, see introduction;
  # Omega is the matrix for Gaussian proposal in Metropolis step;
  # starter is a list providing the starter point;
  # burn is the the number of scans to be discarded as burn-in;
  # thin is the thinning parameter;
  # verbose is the period for printing status of the chain.

  # starter must be a list with the following structure:
  #  starter$theta1, starter$theta2, starter$b , starter$Z; or NULL. In the
  #  latter case the starting point is generated by method of moments.


  ###############--------------- function script

  ### print start time if required
  if(!is.infinite(verbose)) {
    print(paste("GompPois_quasiGibbs: start time at ", Sys.time(), sep = ""))
  }

  ### check verbose
  if (verbose == 0) verbose = nsim + 1

  ### check burn
  if (burn <= 0) burn = 1

  ### compute Cholesky factor of Omega
  cholOmega = t(chol(Omega))




  ########## initialization

  ##### get starting values

  ### if starting values are not provided then use method of moments
  if (is.null(starter)) {
    starter = GompPois_MoM(Nstar)
    # check if estimated values belong to the support of the parameters
    if (starter$theta2 < 0.01) starter$theta2 = 0.01
    if (starter$b > -0.01) starter$b = -0.01
    if (starter$b < -0.99) starter$b = -0.99
    # sample Z from importance density
    starter$IS = c(GompPois_likelihood(
      Nstar, theta1 = starter$theta1, theta2 = starter$theta2, b = starter$b,
      nsim = 1e+4, log = TRUE, details = TRUE
    ))
    starter$Z = starter$IS$Z[, sample(
      c(1:1e+4), size = 1, replace = FALSE, prob = starter$IS$normWeights
    )]
  }

  ### initialize parameter values
  theta1 = starter$theta1
  theta2 = starter$theta2
  b = starter$b
  Z = starter$Z

  a = -b * theta1
  sigmaSq = -b * (2 + b) * theta2
  beta = log(-b / (1 + b))
  V = pi^2 / 3 # just for initialization, it is not used
  W = 1 # just for initialization, it is not used
  U = 1 # just for initialization, it is not used

  ### initialize composite likelihood
  compLike_curr = GompPois_composite_likelihood_cpp(
    Nstar = Nstar, theta1 = theta1, theta2 = theta2, b = b, nsim = 1e+4, d = 1
  )



  ### sample size
  T = length(Nstar)

  ### initialize inverse of B
  invB = matrix(0, nrow = T, ncol = T)

  ### storing vectors
  keep_theta1 = double(nsim)
  keep_theta2 = double(nsim)
  keep_b = double(nsim)

  ### initialize total acceptance counter
  total_accep = 0

  ### initialize true acceptance counter
  true_accep = 0

  ### control variable for acceptance within thinning
  ctrl_accep_thin = FALSE




  ########## draw the chain
  for (insim in (1 - burn):nsim) {

    ithin = 0

    ##### iterate up to thinning value
    while (ithin < thin) {

      ##########################################################################
      #                                                                        #
      #                           update U, V and W                            #
      #                                                                        #
      ##########################################################################

      U = rgamma(1, shape = phi1, rate = phi2 + 1 / theta2)
      V = 1 / rgamma(1, shape = 1, rate = 0.5 + beta^2 / (2 * c))
      W = 1 / rgamma(
        1, shape = 0.5 * (nu + 1),
        rate = 0.5 * (nu + (theta1 - zeta1)^2 / (theta2 * zeta2))
      )



      ##########################################################################
      #                                                                        #
      #                      update theta1, theta2, beta                       #
      #                                                                        #
      ##########################################################################

      ### generate proposal
      prop = c(theta1, log(theta2), beta) + cholOmega %*% rnorm(3)
      theta1_prop = prop[1]
      theta2_prop = exp(prop[2])
      beta_prop = prop[3]
      b_prop = - 1 / (1 + exp(-beta_prop))

      ### compute composite log-likelihood of the proposal
      compLike_prop = GompPois_composite_likelihood_cpp(
        Nstar = Nstar, theta1 = theta1_prop, theta2 = theta2_prop, b = b_prop,
        nsim = 1e+4, d = 1
      )

      ### compute log-prior of the proposal
      prior_prop = dnorm(beta_prop, mean = 0, sd = sqrt(c * V), log = TRUE) +
        dgamma(1 / theta2_prop, shape = 1, rate = U, log = TRUE) -
        2 * log(theta2_prop) + dnorm(
        theta1_prop, mean = zeta1, sd = sqrt(W * theta2_prop * zeta2),
        log = TRUE
      )

      ### compute log-propr of the proposal
      prior_curr = dnorm(beta, mean = 0, sd = sqrt(c * V), log = TRUE) +
        dgamma(1 / theta2, shape = 1, rate = U, log = TRUE) -
        2 * log(theta2) + dnorm(
        theta1, mean = zeta1, sd = sqrt(W * theta2 * zeta2),
        log = TRUE
      )

      LR = compLike_prop + prior_prop - compLike_curr - prior_curr

      ### acceptance test
      if (log(runif(1)) <= LR) {

        theta1 = theta1_prop
        theta2 = theta2_prop
        b = b_prop
        beta_prop = beta_prop
        compLike_curr = compLike_prop

        total_accep = total_accep + 1
        ctrl_accep_thin = TRUE

      }




      ##### end of single complete scan
      if (insim > 0) ithin = ithin + 1 else ithin = thin

    }

    ### check if outside of burn-in period
    if (insim > 0) {

      ### keep values
      keep_b[insim] = b
      keep_theta1[insim] = theta1
      keep_theta2[insim] = theta2

      ### update counter and reset control
      true_accep = true_accep + ctrl_accep_thin
      ctrl_accep_thin = FALSE

      ### print status of the chain
      if (insim %% verbose == 0) {
        cat(paste(
          "iteration ", insim, " of ", nsim, " completed at time ", Sys.time(),
          "\n", "total acceptance rate is ", total_accep / (nsim * thin + burn),
          "\n", "true acceptance rate is ", true_accep / nsim, "\n",
          sep = ""
        ))
      }

    }

  }

  ### print end time if required
  if (!is.infinite(verbose)) {
    print(paste("GompPois_quasiGibbs: end time at ", Sys.time(), sep = ""))
  }

  ### return results
  return(list(
    theta1 = keep_theta1,
    theta2 = keep_theta2,
    b = keep_b,
    total_accep_rate = total_accep / (nsim * thin + burn),
    true_accep_rate = true_accep / nsim
  ))

}





