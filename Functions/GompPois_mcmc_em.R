###############################################################################
#
# Gompertz Model with Poisson Sampling Error: Markov Chain Monte Carlo
#  Expectation Maximixation Algorithm
#
################################################################################


############### description
# This function computes the MLE of the following model:
#
#           Nstar_t | N_t ~ Poisson(N_t)
#           N_t = exp(Z_t)
#           Z_t = a + (1 + b) Z_{t - 1} + eps_t
#           eps_t ~iid Gauss(0, sigmaSq)
#
# It is used an alternative parametrization, that is:
#
#     theta1 = - a / b
#     theta2 = - sigmaSq / (b * (2 + b))
#     beta = 1 / (1 + exp(b))
#
# which implies
#
#     Z_1, Z_2, ..., Z_T ~ Gauss_T ( theta1 1_T, theta2 SigmaBar)
#     SigmaBar_ij = (1 + b ) ^ abs(i - j)
#
# The following scheme is used
#
#     (1) for t = 1, 2, ..., T
#         sample Z_t | Nstar_t, Z_{-t}, beta, theta2, theta1
#         (using acceptance-rejection) and ...
#
#     (2) maximize the log-likelihood by taking ...

#source("extraFunctions.R")
#source("GompPois_likelihood.R")
#source("rpostlogiskolmo.R")

############### function
GompPois_mcmc_em = function(
  Nstar, maxit = 1e+3, abstol = sqrt(.Machine$double.eps),
  nsim = 1e+4, starter = NULL, verbose = +Inf
) {

  # Nstar is the vector of the data, say Nstar_t, t = 1,2,...,T;
  # nsim is the number of simulations for MCMC step;
  # starter is a list providing the starter point;
  # verbose is the period for printing status of the chain.

  # starter must be a list with the following structure:
  #  starter$theta1, starter$theta2, starter$b, or NULL. In the
  #  latter case the starting point is generated by method of moments.

  #--------------
  sub_Gomp_mcmc_Z = function(nsim, Nstar, theta1, theta2, b) {

    mcmc_sample = matrix(nrow = T, ncol = nsim)
    a = -b * theta1
    sigmaSq = -b * (2 + b) * theta2

    # sample Z from importance density
    IS_obj = c(GompPois_likelihood(
      Nstar, theta1 = theta1, theta2 = theta2, b = b,
      nsim = 1e+4, log = TRUE, details = TRUE
    ))
    Z = IS_obj$Z[, sample(
      c(1:1e+4), size = 1, replace = FALSE, prob = IS_obj$normWeights
    )]

    for (insim in 1:nsim) {
      for (t in 1:T) {

        if (t == 1) {
          mu = (theta1 * sigmaSq + (1 + b) * (Z[2] - a) * theta2) / (
            sigmaSq + (1 + b)^2 * theta2
          )
          tauSq = sigmaSq * theta2 / (sigmaSq + (1 + b)^2 * theta2)
        } else if (t == T) {
           mu = a + (1 + b) * Z[T-1]
           tauSq = sigmaSq
        } else {
           mu = (a + (1 + b) * (Z[t+1] + Z[t-1] - a)) / (1 + (1 + b)^2)
          tauSq = sigmaSq / (1 + (1 + b)^2)
        }

        xi = Nstar[t] * tauSq + mu - lambertW_expArg(
          log(tauSq) + Nstar[t] * tauSq + mu
        )

        logC = -exp(xi) + xi * Nstar[t] - 0.5 / tauSq * (xi - mu)^2

        while (TRUE) {
          x = xi + sqrt(tauSq) * rnorm(100)
          check = -rexp(100) <= -exp(x) + x * Nstar[t] -
            0.5 / tauSq * (x - mu)^2 +
            0.5 / tauSq * (x - xi)^2 -
            logC
            if (sum(check) > 0) {
            Z[t] = x[check][1]
            break
          }
        }

      }
      mcmc_sample[, insim] = Z
    }
    mean_z = rowMeans(mcmc_sample)
    var_z = cov(t(mcmc_sample))
    meanExp_z = rowMeans(exp(mcmc_sample))

    return(list(
      mean_z = mean_z,
      var_z = var_z,
      meanExp_z = meanExp_z
    ))
  }
  #--------------


  ###############--------------- function script

  ### print start time if required
  if (!is.infinite(verbose)) {
    print(paste("GompPois_mcmc_em: start time at ", Sys.time(), sep = ""))
  }

  ### check verbose
  if (verbose == 0) verbose = nsim + 1




  ########## initialization

  ##### get starting values

  ### if starting values are not provided then use method of moments
  if (is.null(starter)) {
    starter = GompPois_MoM(Nstar)
    # check if estimated values belong to the support of the parameters
    if(starter$theta2 < 0.01) starter$theta2 = 0.01
    if(starter$b > -0.01) starter$b = -0.01
    if(starter$b < -0.99) starter$b = -0.99
  }

  ### initialize parameter values
  theta1 = starter$theta1
  theta2 = starter$theta2
  b = starter$b


  ### sample size
  T = length(Nstar)

  ### initialize inverse of B
  invB = matrix(0, nrow = T, ncol = T)

  ### initialize the current value of the Q function
  curr_Qval = -Inf

  ### initialize counter of iteration
  iit = 0




  ########## run the optimization
  while (TRUE) {

    ##### Expectation step

    ### run mcmc for computing quantities of interest for Z
    mom_z = sub_Gomp_mcmc_Z(nsim, Nstar, theta1, theta2, b)

    ### extract values
    # mean of Z
    mean_z = mom_z$mean_z
    # variance of Z
    var_z = mom_z$var_z
    # mean of exponential
    meanExp_z = mom_z$meanExp_z

    
    
    ##### Maximization step

    ### get negative logit transformation of b
    beta = log(-b / (1 + b))

    ### run optim
    opt_tmp = tryCatch(
      expr = optim(
        par = c(theta1, theta2, beta),
        fn = function(x) {

          # get theta1
          theta1 = x[1]

          # get theta2 (always postive)
          theta2 = abs(x[2])

          # get b
          b = -1 / (1 + exp(-x[3]))

          # get inverse of B
          invB[1, 1] = 1
          invB[1, 2] = -(1 + b)
          invB[2, 1] = -(1 + b)
          invB[T, T] = 1
          for (t in 2:(T-1)) {
            invB[t, t] = 1 + (1 + b)^2
            invB[t, t + 1] = -(1 + b)
            invB[t + 1, t] = -(1 + b)
          }
          invB = invB / (1 - (1 + b)^2)

          # get the value
          output = -0.5 * T * log(theta2) - 0.5 * (T - 1) * log(-b * (2 + b)) -
            0.5 / theta2 * (
              sum(invB * var_z) +
                colSums(crossprod(invB, Conj(mean_z)) * mean_z) -
                2 * theta1 * sum(c(rowSums(invB)) * mean_z) +
                theta1^2 * sum(invB)
            )

          # return the result
          return(-output)

        },
        method = "BFGS"
      ),
      error = function(err) return("err")
    )

    if (opt_tmp[1] == "err") {
      opt_tmp = optim(
        par = c(theta1, theta2, beta),
        fn = function(x) {

          # get theta1
          theta1 = x[1]

          # get theta2 (always postive)
          theta2 = abs(x[2])

          # get b
          b = -1 / (1 + exp(-x[3]))

          # get inverse of B
          invB[1, 1] = 1
          invB[1, 2] = -(1 + b)
          invB[2, 1] = -(1 + b)
          invB[T, T] = 1
          for (t in 2:(T-1)) {
            invB[t, t] = 1 + (1 + b)^2
            invB[t, t + 1] = -(1 + b)
            invB[t + 1, t] = -(1 + b)
          }
          invB = invB / (1 - (1 + b)^2)

          # get the value
          output = -0.5 * T * log(theta2) - 0.5 * (T - 1) * log(-b * (2 + b)) -
            0.5 / theta2 * (
              sum(invB * var_z) +
                colSums(crossprod(invB, Conj(mean_z)) * mean_z) -
                2 * theta1 * sum(c(rowSums(invB)) * mean_z) +
                theta1^2 * sum(invB)
            )

          # return the result
          return(-output)

        },
        method = "Nelder-Mead"
      )
    }



    ##### get new values of parameters and check convergence

    ### increase by 1 the counter of iterations
    iit = iit + 1

    ### get parameters
    theta1 = opt_tmp$par[1]
    theta2 = abs(opt_tmp$par[2])
    b = -1 / (1 + exp(-opt_tmp$par[3]))

    ### get new value of Q function
    new_Qval = -opt_tmp$value + sum(-meanExp_z + mean_z * Nstar)

    ### print status of the optimization
    if (iit %% verbose == 0) {
      print(paste(
        "iteration ", iit, " (maximum is ", maxit, ") completed at time ",
        Sys.time()," with Q function value = " , new_Qval, sep = ""
      ))
    }

    if (new_Qval - curr_Qval <= abstol || iit >= maxit) {
      break
    } else {
      curr_Qval = new_Qval
    }

  }




  ### print end time if required
  if (!is.infinite(verbose)) {
    print(paste("GompPois_mcmc_em: end time at ", Sys.time(), sep = ""))
  }

  ### return results
  return(c(theta1, theta2, b))

}





############### appendix

if (FALSE) { # appendix script is not run

  # debugging
  {
    rm(list = ls()); gc(); cat("\14")
    source("GompPois_mcmc_em.R")
    set.seed(1994)
    nsim = 1e+4
    T = 50
    theta1 = 1.9244
    theta2 = 0.4726 ^ 2 # that is 0.2233508
    b = -0.8 # -0.24

    Nstar = GompPois_simulate(T, theta1 = theta1, theta2 = theta2, b = b)
    rm(list = c("T", "theta1", "theta2", "b"))

    psi1 = 0.01
    psi2 = 0.01
    eta1 = 0
    eta2 = 100
    c = 1
    starter = NULL
    burn = 1
    thin = 1
    verbose = 100
    start_time = Sys.time()
    res = GompPois_quasiGibbs(
      nsim, Nstar = Nstar, psi1 = psi1, psi2 = psi2, eta1 = eta1, eta2 = eta2,
      c = c, starter = starter, burn = burn, thin = thin, verbose = verbose
    )
    end_time = Sys.time()
  }

  #difftime(end_time, start_time)

  mean(res$theta1)
  mean(res$theta2)
  mean(res$b)

  acf(res$theta1)
  acf(res$theta2)
  acf(res$b)
  #plot(density(res$b))

  plot(res$theta1, type = "l")
  plot(res$theta2, type = "l")
  plot(res$b, type = "l")

  sns::ess(res$theta1)
  sns::ess(res$theta2)
  sns::ess(res$b)

  ###############

  # check inversion of B

  b = -0.24
  T = 1e+3

  B = (1 + b)^(abs(outer(1 : T, 1 : T, "-"))) # get B matrix
  invB1 = chol2inv(chol(B))

  invB2 = matrix(0, nrow = T, ncol = T)
  invB2[1, 1] = 1
  invB2[1, 2] = -(1 + b)
  invB2[2, 1] = -(1 + b)
  invB2[T, T] = 1
  for (t in 2:(T-1)) {
    invB2[t, t] = 1 + (1 + b)^2
    invB2[t, t + 1] = -(1 + b)
    invB2[t + 1, t] = -(1 + b)
  }
  invB2 = invB2 / (1 - (1 + b)^2)

  invB1[1:3, 1:3]
  invB2[1:3, 1:3]

  B2 = chol2inv(chol(invB2))
  B2[1:3, 1:3]
  B[1:3, 1:3]
}